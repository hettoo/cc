\documentclass[a4paper]{article}

\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[nounderscore]{syntax}
\usepackage{bussproofs}

\setlength{\grammarparsep}{0pt}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\title{SPL Type Checker}
\author{Tom Sanders and Gerco van Heerdt}

\begin{document}

\maketitle

Recall our final version of the SPL grammar.
\setlength{\grammarindent}{7.1em}
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <VarDecl> | <FunDecl>

    <VarDecl> ::= <Type> <id> `=' <Exp> `;'

    <FunDecl> ::= <RetType> <id> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>+ `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <id> | <BasicType> | `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= <Type> <id> [\,`,' <FArgs>\,]

    <Stmt> ::= `{' <Stmt>* `}' | <StmtId> `;' | `return' [\,<Exp>\,] `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>

    <StmtId> ::= <id> (\,[\,<Field>\,] `=' <Exp> | `(' [\,<ActArgs>\,] `)'\,)

    <Exp> ::= <Exp1> [\,`:' <Exp>\,]

    <Exp1> ::= <Exp2> (\,(\,`&&' | `||'\,) <Exp2>\,)*

    <Exp2> ::= <Exp3> (\,(\,`==' | `!='\,) <Exp3>\,)*

    <Exp3> ::= <Exp4> (\,(\,`<' | `>' | `<=' | `>='\,) <Exp4>\,)*

    <Exp4> ::= <Exp5> (\,(\,`+' | `-'\,) <Exp5>\,)*

    <Exp5> ::= <Exp6> (\,(\,`*' | `/' | `%'\,) <Exp6>\,)*

    <Exp6> ::= (\,`!' | `-'\,) <Exp6> | <NonOpExp>

    <NonOpExp> ::= <int> | <char> | <bool> | `[]' | <ExpId>
    \alt `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <ExpId> ::= <id> (\,[\,<Field>\,] | `(' [\,<ActArgs>\,] `)'\,)

    <Field> ::= `.' (\,`hd' | `tl' | `fst' | `snd'\,) [\,<Field>\,]

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <int> ::= [\,`-'\,] <digit>+

    <char> ::= `\'' <any> `\''

    <bool> ::= `False' | `True'

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*
\end{grammar}

What matters, however, is not the syntax used to recognize a program, but rather the syntax used to store it.
For instance, the grammar describing our expressions is shown below.
\setlength{\grammarindent}{4.1em}
\begin{grammar}
    <Exp> ::= Int $i$ | Bool $b$ | Char $c$ | Nil | $\ominus$<Exp> | <Exp> $\otimes$ <Exp>
    \alt (\,<Exp>, <Exp>\,) | Var <id> (\,<Field>\,)* | Fun <id> (\,Exp\,)*
\end{grammar}
Here $\ominus$ stands for a unary operator, and $\otimes$ can be any binary operator.

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Int } i : \text{Int}$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Bool } i : \text{Bool}$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Char } i : \text{Char}$}
    \DisplayProof
\end{center}

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Nil} : \forall a.\,[a]$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_1 : \sigma_1$}
    \AxiomC{$\Gamma \vdash e_2 : \sigma_2$}
    \BinaryInfC{$\Gamma \vdash (e_1, e_2) : (\sigma_1, \sigma_2)$}
    \DisplayProof
\end{center}

\begin{center}
    \AxiomC{$(i, \sigma) \in \Gamma$}
    \UnaryInfC{$\Gamma \vdash \text{Var } i\;[\,] : \sigma$}
    \DisplayProof
\end{center}

\begin{center}
    \AxiomC{$(i, \sigma) \in \Gamma$}
    \AxiomC{$\Gamma \vdash f : \sigma \to \tau$}
    \AxiomC{$\{(v, t) \in \Gamma \mid v \neq i\}, i : \tau \vdash \text{Var } i\;r : \upsilon$}
    \TrinaryInfC{$\Gamma \vdash \text{Var } i\;(f :: r) : \upsilon$}
    \DisplayProof
\end{center}

% TODO: split variable and function contexts
\begin{center}
    \AxiomC{$(i, \sigma) \in \Gamma$}
    \UnaryInfC{$\Gamma \vdash \text{Fun } i\;[\,] : \sigma$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_j : \sigma_j$}
    \AxiomC{$(i, (\sigma_1, \sigma_2, \ldots, \sigma_n) \to \tau) \in \Gamma$}
    \BinaryInfC{$\Gamma \vdash \text{Fun } i\;[e_1, e_2, \ldots, e_n] : \tau$}
    \DisplayProof
\end{center}

\end{document}
