\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[nounderscore]{syntax}

\setlength{\grammarparsep}{0pt}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\title{SPL Parser Grammar}
\author{Tom Sanders and Gerco van Heerdt}

\begin{document}

\maketitle

We recall first the original grammar of the Simple Programming Language\footnote{%
    tl;dr: the final grammar is at the end of this document.
}.
\setlength{\grammarindent}{6.8em}
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <VarDecl> | <FunDecl>

    <VarDecl> ::= <Type> <id> `=' <Exp> `;'

    <FunDecl> ::= <RetType> <id> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>+ `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <id> | <BasicType> | `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= [\,<FArgs> `,'\,] <Type> <id>

    <Stmt> ::= `{' <Stmt>* `}' | <FunCall> `;' | `return' [\,<Exp>\,] `;'
    \alt <id> <Field> `=' <Exp> `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>

    <Exp> ::= <int> | <char> | `False' | `True' | `[]' | <id> <Field>
    \alt <FunCall> | <Op1> <Exp> | <Exp> <Op2> <Exp>
    \alt `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <Field> ::= [\,<Field> `.' (\,`hd' | `tl' | `fst' | `snd'\,)\,]

    <FunCall> ::= <id> `(' [\,<ActArgs>\,] `)'

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <Op1> ::= `!' | `-'

    <Op2> ::=  `*' | `/' | `%' | `+' | `-'
    \alt `<' | `>' | `<=' | `>=' | `==' | `!='
    \alt `&&' | `||' | `:'

    <int> ::= [\,`-'\,] <digit>+

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*
\end{grammar}

The operators should adhere to the usual precedence and associativity rules.
The following grammar is transformed from the previous one in order to achieve that.
Note that only list construction is right-associative.
\setlength{\grammarindent}{7.1em}
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <VarDecl> | <FunDecl>

    <VarDecl> ::= <Type> <id> `=' <Exp> `;'

    <FunDecl> ::= <RetType> <id> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>+ `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <id> | <BasicType> | `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= [\,<FArgs> `,'\,] <Type> <id>

    <Stmt> ::= `{' <Stmt>* `}' | <FunCall> `;' | `return' [\,<Exp>\,] `;'
    \alt <id> <Field> `=' <Exp> `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>

    <Exp> ::= <OpExp> | <NonOpExp>

    <OpExp> ::= <OpExp1> [\,`:' <OpExp>\,]

    <OpExp1> ::= [\,<OpExp1> (\,`&&' | `||'\,)\,] <OpExp2>

    <OpExp2> ::= [\,<OpExp2> (\,`==' | `!='\,)\,] <OpExp3>

    <OpExp3> ::= [\,<OpExp3> (\,`<' | `>' | `<=' | `>='\,)\,] <OpExp4>

    <OpExp4> ::= [\,<OpExp4> (\,`+' | `-'\,)\,] <OpExp5>

    <OpExp5> ::= [\,<OpExp5> (\,`*' | `/' | `%'\,)\,] <OpExp6>

    <OpExp6> ::= (\,`!' | `-'\,) <OpExp6> | <NonOpExp>

    <NonOpExp> ::= <int> | <char> | `False' | `True' | `[]' | <id> <Field>
    \alt <FunCall> | `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <Field> ::= [\,<Field> `.' (\,`hd' | `tl' | `fst' | `snd'\,)\,]

    <FunCall> ::= <id> `(' [\,<ActArgs>\,] `)'

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <int> ::= [\,`-'\,] <digit>+

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*
\end{grammar}

We will now eliminate left recursion.
The first step is to remove empty productions.
These are only present in the \synt{Field} rule, which we easily adapt.
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <VarDecl> | <FunDecl>

    <VarDecl> ::= <Type> <id> `=' <Exp> `;'

    <FunDecl> ::= <RetType> <id> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>+ `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <id> | <BasicType> | `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= [\,<FArgs> `,'\,] <Type> <id>

    <Stmt> ::= `{' <Stmt>* `}' | <FunCall> `;' | `return' [\,<Exp>\,] `;'
    \alt <id> [\,<Field>\,] `=' <Exp> `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>

    <Exp> ::= <OpExp> | <NonOpExp>

    <OpExp> ::= <OpExp1> [\,`:' <OpExp>\,]

    <OpExp1> ::= [\,<OpExp1> (\,`&&' | `||'\,)\,] <OpExp2>

    <OpExp2> ::= [\,<OpExp2> (\,`==' | `!='\,)\,] <OpExp3>

    <OpExp3> ::= [\,<OpExp3> (\,`<' | `>' | `<=' | `>='\,)\,] <OpExp4>

    <OpExp4> ::= [\,<OpExp4> (\,`+' | `-'\,)\,] <OpExp5>

    <OpExp5> ::= [\,<OpExp5> (\,`*' | `/' | `%'\,)\,] <OpExp6>

    <OpExp6> ::= (\,`!' | `-'\,) <OpExp6> | <NonOpExp>

    <NonOpExp> ::= <int> | <char> | `False' | `True' | `[]' | <id> [\,<Field>\,]
    \alt <FunCall> | `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <Field> ::= [\,<Field>\,] `.' (\,`hd' | `tl' | `fst' | `snd'\,)

    <FunCall> ::= <id> `(' [\,<ActArgs>\,] `)'

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <int> ::= [\,`-'\,] <digit>+

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*
\end{grammar}

Fortunately, there are no cycles in our current grammar, so we skip to the last step: eliminating immediate left recursion.
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <VarDecl> | <FunDecl>

    <VarDecl> ::= <Type> <id> `=' <Exp> `;'

    <FunDecl> ::= <RetType> <id> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>+ `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <id> | <BasicType> | `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= <Type> <id> [\,`,' <FArgs>\,]

    <Stmt> ::= `{' <Stmt>* `}' | <FunCall> `;' | `return' [\,<Exp>\,] `;'
    \alt <id> [\,<Field>\,] `=' <Exp> `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>

    <Exp> ::= <OpExp> | <NonOpExp>

    <OpExp> ::= <OpExp1> [\,`:' <OpExp>\,]

    <OpExp1> ::= <OpExp2> (\,(\,`&&' | `||'\,) <OpExp2>\,)*

    <OpExp2> ::= <OpExp3> (\,(\,`==' | `!='\,) <OpExp3>\,)*

    <OpExp3> ::= <OpExp4> (\,(\,`<' | `>' | `<=' | `>='\,) <OpExp4>\,)*

    <OpExp4> ::= <OpExp5> (\,(\,`+' | `-'\,) <OpExp5>\,)*

    <OpExp5> ::= <OpExp6> (\,(\,`*' | `/' | `%'\,) <OpExp6>\,)*

    <OpExp6> ::= (\,`!' | `-'\,) <OpExp6> | <NonOpExp>

    <NonOpExp> ::= <int> | <char> | `False' | `True' | `[]' | <id> [\,<Field>\,]
    \alt <FunCall> | `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <Field> ::= `.' (\,`hd' | `tl' | `fst' | `snd'\,) [\,<Field>\,]

    <FunCall> ::= <id> `(' [\,<ActArgs>\,] `)'

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <int> ::= [\,`-'\,] <digit>+

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*
\end{grammar}

\end{document}
