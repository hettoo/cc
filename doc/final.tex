\documentclass[a4paper]{article}

\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[nounderscore]{syntax}
\usepackage{bussproofs}

\setlength{\grammarparsep}{0pt}
\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}

\title{A Compiler for SPL with Custom Data Types}
\author{Tom Sanders and Gerco van Heerdt}

\begin{document}

\maketitle

\section{Syntax}

Our language has been updated with custom data types, generic field getters and setters, and constructor matching. % TODO: maybe explain this informally in detail first?
This has affected our grammar, of which the new version is shown below.
\setlength{\grammarindent}{7.6em}
\begin{grammar}
    <SPL> ::= <Decl>+

    <Decl> ::= <DataDecl> | <VarDecl> | <FunDecl>

    <DataDecl> ::= `data' <uid> <lid>* `=' [\,<Constructor> (\,`|' <Constructor>\,)*\,] `;'

    <Constructor> ::= <uid> [\,`(' [\,<FArgs>\,] `)'\,]

    <VarDecl> ::= <Type> <lid> [\,`=' <Exp>\,] `;'

    <FunDecl> ::= <RetType> <lid> `(' [\,<FArgs>\,] `)' `{' <VarDecl>* <Stmt>* `}'

    <RetType> ::= <Type> | `Void'

    <Type> ::= <lower> | <BasicType> | `\\' <uid> <Type>* `/'
    \alt `(' <Type> `,' <Type> `)' | `[' <Type> `]'

    <BasicType> ::= `Int' | `Bool' | `Char'

    <FArgs> ::= <Type> <lid> [\,`,' <FArgs>\,]

    <Stmt> ::= `{' <Stmt>* `}' | <StmtId> `;' | `return' [\,<Exp>\,] `;'
    \alt `if' `(' <Exp> `)' <Stmt> [\,`else' <Stmt>\,]
    \alt `while' `(' <Exp> `)' <Stmt>
    \alt `case' <Exp> `{' (\,<uid> <Stmt>\,)* `}'

    <StmtId> ::= <lid> (\,[\,<Field>\,] `=' <Exp> | `(' [\,<ActArgs>\,] `)'\,)

    <Exp> ::= <Exp1> [\,`:' <Exp>\,]

    <Exp1> ::= <Exp2> (\,(\,`&&' | `||'\,) <Exp2>\,)*

    <Exp2> ::= <Exp3> (\,(\,`==' | `!='\,) <Exp3>\,)*

    <Exp3> ::= <Exp4> (\,(\,`<' | `>' | `<=' | `>='\,) <Exp4>\,)*

    <Exp4> ::= <Exp5> (\,(\,`+' | `-'\,) <Exp5>\,)*

    <Exp5> ::= <Exp6> (\,(\,`*' | `/' | `%'\,) <Exp6>\,)*

    <Exp6> ::= (\,`!' | `-'\,) <Exp6> | <NonOpExp>

    <NonOpExp> ::= <int> | <char> | <bool> | `[]' | <IdExp> | <ConsExp>
    \alt `(' <Exp> `)' | `(' <Exp> `,' <Exp> `)'

    <ConsExp> ::= <uid> [\,`(' [\,<ActArgs>\,] `)'\,]

    <IdExp> ::= <lid> (\,[\,<Field>\,] | `(' [\,<ActArgs>\,] `)'\,)

    <Field> ::= `.' <id> [\,<Field>\,]

    <ActArgs> ::= <Exp> [\,`,' <ActArgs>\,]

    <int> ::= [\,`-'\,] <digit>+

    <char> ::= `\'' <any> `\''

    <bool> ::= `False' | `True'

    <id> ::= <alpha> (\,`_' | <alphaNum>\,)*

    <lid> ::= <lower> (\,`_' | <alphaNum>\,)*

    <uid> ::= <upper> (\,`_' | <alphaNum>\,)*
\end{grammar}

Names of custom types and constructors must begin with an uppercase character; we have restricted variable and function names to begin with a lowercase character, and polymorphic type identifiers may only be single lowercase characters.
Note that there is a minor other change: a variable declaration does not require an initial assignment.

\section{Semantic Analysis}

Binding time analysis consists in determining where variables that are used in the program were bound.
We use the usual precedence rules to do this: variables defined in a subscope override ones defined on a higher level; it is an error to redefine a variable in the same scope.
Note that both function arguments and function bodies introduce a new scope.

Typechecking a function consists in ensuring that the returned values for all possible executions of the function (assuming just that it terminates) are compatible with the type given to it.
An execution not hitting a return statement is equivalent to it returning a variable of type Void in the end.
Of course there are no such variables, but this is in turn modeled by the return statement without parameter.

Functions may be overloaded, but it is not allowed that multiple versions of a function apply for any possible way the function can be called.
Note that the current implementation does not allow overloading the return type of a function at all.

For convenience, we use the notation $\Gamma = (\Gamma_v, \Gamma_f)$ expressing that a context $\Gamma$ is made up of a variable context $\Gamma_v$ and a function context $\Gamma_f$.

\section{Typing rules}

What matters for typing is not the syntax used to recognize a program, but rather the syntax used to store it, particularly the grammar describing our expressions, which is shown below.
\setlength{\grammarindent}{4.1em}
\begin{grammar}
    <Exp> ::= Int $i$ | Bool $b$ | Char $c$ | $\ominus$<Exp> | <Exp> $\otimes$ <Exp>
    \alt Var <id> <Field>* | Fun <id> <Exp>* | Cons <id> <Exp>*
\end{grammar}
Here $\ominus$ stands for a unary operator, and $\otimes$ can be any binary operator.

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Int } i : \text{Int}$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Bool } i : \text{Bool}$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Char } i : \text{Char}$}
    \DisplayProof
\end{center}

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Nil} : \forall a.\,[a]$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_1 : \sigma_1$}
    \AxiomC{$\Gamma \vdash e_2 : \sigma_2$}
    \BinaryInfC{$\Gamma \vdash (e_1, e_2) : (\sigma_1, \sigma_2)$}
    \DisplayProof
    \qquad
    \AxiomC{$(i, \sigma) \in \Gamma_v$}
    \UnaryInfC{$\Gamma \vdash \text{Var } i\;[\,] : \sigma$}
    \DisplayProof
\end{center}

\begin{center}
    \AxiomC{$(i, \sigma) \in \Gamma_v$}
    \AxiomC{$\Gamma \vdash f : \sigma \to \tau$}
    \AxiomC{$((\Gamma_{v \setminus i}, i : \tau), \Gamma_f) \vdash \text{Var } i\;r : \chi$}
    \TrinaryInfC{$\Gamma \vdash \text{Var } i\;(f :: r) : \chi$}
    \DisplayProof
\end{center}
Here $\Gamma_{v \setminus i} = \{(v, t) \in \Gamma_v \mid v \neq i\}$.

Note that the above rule requires us to type field specifiers as well.
We will do this later.

\begin{center}
    \AxiomC{$\forall_{1 \le j \le n}\,\Gamma \vdash e_j : \sigma_j$}
    \AxiomC{$(i, (\sigma_1, \sigma_2, \ldots, \sigma_n) \to \tau) \in \Gamma_f$}
    \BinaryInfC{$\Gamma \vdash \text{Fun } i\;(e_1, e_2, \ldots, e_n) : \tau$}
    \DisplayProof
\end{center}

Finally, we have to specify all operators.

\begin{center}
    \AxiomC{$\Gamma \vdash e : \text{Int}$}
    \UnaryInfC{$\Gamma \vdash -e : \text{Int}$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e : \text{Bool}$}
    \UnaryInfC{$\Gamma \vdash\;!e : \text{Bool}$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_1 : \sigma$}
    \AxiomC{$\Gamma \vdash e_2 : \sigma$}
    \BinaryInfC{$\Gamma \vdash e_1 \bullet e_2 : \sigma$}
    \DisplayProof
\end{center}
where $\bullet \in \{+, -, *, /, \%\}$.

\begin{center}
    \AxiomC{$\Gamma \vdash e : \sigma$}
    \AxiomC{$\Gamma \vdash l : [\sigma]$}
    \BinaryInfC{$\Gamma \vdash (e : l) : [\sigma]$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_1 : \sigma$}
    \AxiomC{$\Gamma \vdash e_2 : \sigma$}
    \BinaryInfC{$\Gamma \vdash e_1 \diamond e_2 : \text{Bool}$}
    \DisplayProof
\end{center}
with $\diamond \in \{==, <, >, <=, >=, !\!=\}$.

\begin{center}
    \AxiomC{$\Gamma \vdash e_1 : \text{Bool}$}
    \AxiomC{$\Gamma \vdash e_2 : \text{Bool}$}
    \BinaryInfC{$\Gamma \vdash e_1 \text{ \&\& } e_2 : \text{Bool}$}
    \DisplayProof
    \qquad
    \AxiomC{$\Gamma \vdash e_1 : \text{Bool}$}
    \AxiomC{$\Gamma \vdash e_2 : \text{Bool}$}
    \BinaryInfC{$\Gamma \vdash e_1 \text{ \textbar\textbar{} } e_2 : \text{Bool}$}
    \DisplayProof
\end{center}

Field specifiers are given by the following grammar:
\setlength{\grammarindent}{4.3em}
\begin{grammar}
    <Field> ::= Head | Tail | First | Second
\end{grammar}

The types of these are given by the axioms below.
\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Head} : [\sigma] \to \sigma$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Tail} : [\sigma] \to [\sigma]$}
    \DisplayProof
\end{center}
\begin{center}
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{First} : (\sigma_1, \sigma_2) \to \sigma_1$}
    \DisplayProof
    \qquad
    \AxiomC{}
    \UnaryInfC{$\Gamma \vdash \text{Second} : (\sigma_1, \sigma_2) \to \sigma_2$}
    \DisplayProof
\end{center}

Finally, we have the following built-in functions, typed through context initialization:
\[
    \begin{array}{lcl}
        \mathit{isEmpty} & : & [\sigma] \to \text{Bool} \\
        \mathit{print}   & : & \sigma \to \text{Void} \\
        \mathit{read}    & : & \text{Int}
    \end{array}
\]
Here Void simply indicates the absence of a return value.
Note that we do not allow overloading or polymorphism purely on the return type, and so we choose to fix the type of the $\mathit{read}$ function to Int.
The reason for this is to avoid ambiguity: instead of as an expression a function call may appear as a statement, in which case the desired return type is not defined.
We further reject overloading when two versions of a function potentially apply to a certain same combination of argument types.

\section{Compilation Schemes}

We employ \emph{by-value} assignments and calling: a copy of an object---as shallow as possible---is made on assignment.
For tuples and lists this value is a pointer to objects on the heap, but note that the heap is immutable because of the assignment convention.
Thus, an object passed to a function will never actually be modified by that function.
Our current implementation does never actually free memory from the heap.

All objects are represented on the stack with a single value.
As mentioned above, tuples and lists are stored on the heap.
In the case of a tuple the first object is stored first, followed by the second object; for a list we store the tail first and the head second.
The empty list is represented by a null pointer.

A program compiled by our compiler first assigns to the global variables in order their initial values, after which it calls the main function of which the return value, if any, is printed.
Our implementation uses a todo list maintaining the instances of functions that still need to be compiled.
Because of our design choices all types are known at compile time, so we can provide polymorphism simply through overloading as only a finite number of instances of a function can be called by a program.

On a more technical level, whenever we encounter a function call, we reserve room for all the parameters and variables in the relevant function and assign the values of the parameters.
The function is then called, and if it returns a value this will be stored in the return register.
For function calls as statements this can simply be ignored, but if the function call is used as an expression it will load the value of that register onto the stack (after the variables of the function are unlinked).

At the beginning of the program we copy the value of the stack pointer to another register (R7) such that we can calculate at any point the addresses of the global variables.

Many (cases of) built-in functions and operators are implemented through a standard library.
The remaining primitive cases (Int/Char printing, basic operators, etc.) are compiled inline.

\section{Build Instructions}

Building the project requires a modern Haskell compiler and a Make-like system.
Running \verb|make| in the project root will build the compiler in the \verb|build| folder.
Tests can either be run manually by feeding SPL source files into the compiler with \verb|build/compiler < program.spl| or automatically by calling \verb|make tests| in the project root to run a set of predefined tests.
If no problems are encountered, the compiler generates the file \verb|a.ssm| containing the compiled program.

\end{document}
